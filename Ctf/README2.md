# DNS 行为
在互联网冲浪中，我们已经习惯了输入域名连接网站。也许你有了解过网络世界大家的「坐标」都是 IP 地址，但是 DNS 解析怎么找到 IP 地址？更有时，同一个域名申请还会返回不同的地址，
这所谓 CDN 是如何实现的？

DNS 解析流程

把域名转换成 IP 地址，就是 DNS 服务器天天干的事情。DNS 全称为 Domain Name System（域名系统），当我们输入一个域名（如 chralpha.com），DNS 查询流程大概是：

浏览器先查询浏览器缓存，发现并没有找到 chralpha.com 的解析记录
浏览器向系统发起请求查询解析结果，通常系统也有一层缓存，但仍然没有找到 chralpha.com 的地址
系统向上游 DNS 服务器发起请求，系统中可以自行配置 DNS 服务器，假设我使用的是 1.0.0.1，那么操作系统就会向 1.0.0.1 发送查询请求
不论是再向上级查询还是缓存生效，1.0.0.1 最终都会返回一个对应的 IP 地址，之后浏览器就可以拿着这个 IP 地址发起请求了

至于 1.0.0.1 如何找到 chralpha.com 的 IP 地址呢？如果有缓存，那么直接返回即可。否则将一层层向上查询，直到根域名服务器。全球有 13 台根域名服务器，同时还有几百台备用服务器。根域名服务器会先根据最后的顶级域名，所有域名都必须以顶级域名结尾（如 com, org 等）。在对应顶级域名位置查询二级域名，也就是 chralpha。在你注册域名的时候，域名注册商就会给你开通一个地址，里面存放了域名的 NS（Name Server） 信息，用于了解该去哪里查询域名的 DNS 记录。我将域名的 NS 记录修改到 Cloudflare，自然该处保存着 Cloudflare 的地址。此时向该地址请求便能很快找到对应解析记录。

我们刚刚默认系统使用 1.0.0.1 作为 DNS 服务器，事实上这是根据系统设置决定的。你可以自由选择公网或者运营商提供的 DNS 服务器。

![图片](https://user-images.githubusercontent.com/79394963/150638567-b31d327e-4737-485d-b306-6277e3f3f6f2.png)


以上就是一次 DNS 解析的完整流程。看似很长，但实则由于缓存机制的存在，通常这个过程是比较无感的，悄无声息间便完成了。

当然，如果你向 chralpha.com 发起请求，得到的并非 200 正常返回值，而是 301 跳转。因为我将 chralpha.com 重定向至 blog.ichr.me，之后浏览器又会向 blog.ichr.me 发起查询。

CDN 加速原理
从上面的流程来看，一个域名通常对应着一个记录。但是想必你也听说过 CDN 加速。

CDN (Content Delivery Network)，内容分发网络。在现有的网络中再添加一层缓存层，并将网站内容分发到多个边缘节点上。受到请求只从距离用户最近的节点调取。

有点类似「空间换时间」的做法。以此可以加快访问速度，降低骨干网压力。

但是同时，我们发现即便是同一个域名，不同位置的用户查询需要返回不同位置对应最近的 CDN 节点。所以在 DNS 解析过程中需要一定特殊手段实现。

访问流程
我们假设 chralpha.com 应用了 CDN 服务，这时如果在浏览器中敲入此域名，和上面 DNS 解析流程一样，浏览器会得到一个记录。但注意这里不再是源的记录，而是 CDN 服务器的记录。通常通过 CNAME 指向 CDN 专用的 DNS 服务器。这个专用 DNS 服务器不只是在缓存索引或者向上级查询这么简单，它会利用请求的 meta 信息，根据发起请求 IP 端判断哪一个边缘节点路由更近，便返回该节点 IP 地址。

![图片](https://user-images.githubusercontent.com/79394963/150638612-28033006-917a-4d6f-a86d-bc71f26b9a9a.png)


*图片来自 Cloudflare

这只是一个 function 的事情，DNS 查询带来的性能损耗几乎可以忽略不计，但是带来的速度提升却是实实在在的。而且带来的好处还有隐藏源站地址，避免被攻击。



 function search(request) {
      if (请求对象为 "chralpha.com") {
      if (请求发起地址在中国) {
            返回位于中国的边缘服务器地址
        } else if (请求发起地在北美) {
            返回位于北美的边缘服务器地址
        }
        ...
    }
 }


  这段伪代码实现非常粗糙，但原理大致如此。通常 CDN 专用 DNS 服务器可以配置某些高精度 IP 地址库达到更精确的判断效果。

分发方式
一般 CDN 有两种分发手段：Push CDN 和 Pull CDN。

Push CDN 是一种主动分发技术，通常由网站管理员主导。由源节点主动通过 HTTP/FTP 等协议主动分发到边缘节点缓存，如在每次更新的时候将内容预分发到 CDN 节点上。这样无论何时用户向 CDN 节点发起请求时总有最新的缓存可供使用，打开速度也会更快一点。但缺点是不能更好地按需配置，分发所有内容通常会带上一些调用不频繁的资源，降低存储效率，成本也更高。现在 Push CDN 一般可以根据用户访问统计调整分发策略，决定分发那些内容。不过这样一来未分发的资源调用速度会有所下降，各有取舍吧。

Pull CDN 则更像被动分发技术，使用体验视用户访问情况而定。Pull CDN 默认情况下先什么都不动，受到请求时匹配缓存，如果本地有缓存且还没有过期，便直接返回缓存；否则就向源站请求，并将从源站得到的资源缓存下来，设置缓存有效期。Pull CDN 通常配置简单，而且可以根据访问情况灵活调配。但是由于是根据请求缓存，第一次访问或者缓存过期后向源站发起请求速度还是会下降，对于一些流量不大的站点效果远不如 Push CDN。同时还有一定的滞后性，在网站内容更改过后 CDN 节点缓存仍未过期，导致边缘服务器直接返回缓存从而无法及时得到最新内容。这就需要平衡缓存过期时间：过长导致内容时效性影响，过短导致速度体验下降。

由分发方式可知，CDN 需要更多的服务器资源，所以市面上的私人对象存储服务绝大多数都是收费的。有的是按流量计费，有的需要购买流量包等。不过付出一定金额带来的体验上升还是比较可观的，且自己可以更好控制内容分发效果。

与此同时也有许多公共免费 CDN 服务例如通过 jsDelivr 调用 GitHub 仓库资源，这次 jsDelivr 的 CDN 域名（cdn.jsdelivr.net）会帮我利用专用 DNS 服务器返回距离我最近的 CDN 节点。这时向该节点发出请求。当该节点发现本地无法匹配资源，便会向 GitHub 源位置发起请求，并将得到的资源本地缓存好，设置过期时限。如果有和我挨得比较近的小伙伴也访问这个仓库，那么就会直接从该 CDN 节点返回资源，不用重新回到 GitHub 索取，从而加快访问速度。

但是从 jsDelivr 每日流量来看，除非热门项目，其他资源的命中率是比较低的。而使用 jsDelivr 更多是为了稳定而已。因为 jsDelivr 有网宿备案和国内节点，相比直接访问国内时常抽风的 GitHub，通过 jsDelivr 请求 GitHub 资源或许会更加稳定。

# 非正常行为
DNS 劫持
如果通过某些手段获取 DNS 服务器的控制权，便可人为操纵查询结果。将结果指向修改过的 IP 地址，以实现访问导向假网址或者直接导致无法访问。

这种行为最常出现在 ISP 提供的免费 DNS 服务器上。有些 ISP 会对 DNS 投毒引导至自己的服务器上，降低外网压力，甚至植入广告获利。有些 ISP 会积极响应号召，将某些「不合适」的网站返回错误的解析结果。还有 ISP 调高 TTL 使 DNS 请求减少导致无法及时得到最新记录。

不仅时 ISP 专供 DNS，部分公网 DNS 也可能会有一些小手脚。

如果只是单纯 DNS 劫持还是比较容易解决的，选取一个合适的公共 DNS 即可。如 Cloudflare DNS (1.1.1.1, 1.0.0.1) ，或者 Google DNS (8.8.8.8, 8.8.4.4) ，这些国外互联网巨头一般不容易受到 某些组织 牵动，可以提供稳定的解析服务。

但绝大多数不正常 DNS 行为都不仅仅是 DNS 劫持，相比之下应对 DNS 污染更加麻烦。

DNS 污染
虽然有绝对正确的权威 DNS 服务器，但是为了加快查询效率，通常递归 DNS 服务器上会设置缓存机制，命中已缓存的域名便不再继续向上级查询。

如果我们回顾一下 DNS 解析流程，想访问网站就必须将域名转换为对应的 IP 地址。而目前主流 DNS 请求都是基于 UDP 连接，UDP 连接最大的问题就是没有一个可信的验证机制，查询也十分容易被悄无声息地篡改。

如果模拟一个被污染的域名解析请求，如 chralpha.com ：

A 在浏览器中敲入此域名 chralpha.com，未命中缓存，便向 DNS 服务器 C 发起请求
在路由至 C 的途中需要许多中间设备转发，假设 B 是其中一台
由于 DNS 请求使用 53 端口的 UDP 连接，通过对这个端口查询流量进行入侵检测，一旦发现匹配到规则集中的链接便直接返回虚假结果
作为 A 至 C 链路上的一个节点，B 显然可以提前代替 C 返回错误结果给 A，而缺少验证机制也让 A 无法察觉
A 收到错误的地址并发起请求，当然它得不到任何想要的结果
根据规定，查询者 A 只认第一个结果并丢弃后面的，由此肯定无法成功访问那些被关进小黑屋里的网站。

这样即便不用操控 DNS 服务商，通过在合适的路由上部署污染匹配机制也能让用户无法获得正确的 IP 地址。

对于 DNS 劫持而言，只要选取一个安全靠谱的公共 DNS 服务即可。主要来看看后者，DNS 污染的解决。不过除了一劳永逸的代理外，还有其他方法可供选择。

解决手段
DNSSEC
确实，当前互联网已经离不开 DNS。你访问的每一个网页、每一封电子邮件，都需要 DNS 将便于人们使用的域名转为便于机器识别的 IP 地址。

而 DNS 被设计出来之时，互联网规模远比现在小得多，其安全性也并未得到重视。无法做到真实性检验，导致查询结果，无论是递归 DNS 得到的还是用户收到的，都很容易被仿冒伪造。

事实上工作组早就意识到问题，也开始寻找解决方案，DNS 安全扩展（DNSSEC）便应运而生。

DNSSEC 使用 非对称加密算法 对加密进行数字签名，在原始 DNS 协议中新增了：

数据来源验证：解析器可以通过加密的方式验证收到的数据是否确实来自其认定的数据传送区域。
数据完整性保护：解析器可以确信，自区域所有者使用区域私钥初次进行数据签名以来，数据在传输过程中并未遭到修改。
这两项功能主要凭借新增的资源记录类型：DNSKEY (DNS Public Key) 实现。

问题又来了，既然使用私钥签名使得无法伪造查询结果，但是为了验证签名公钥必须一同公开下发。那对公钥动手脚，这样无法通过下方的公钥解开原本使用私钥加密的内容，而终端无法确认是公钥被篡改还是查询结果被伪造。这种不确定也使无法正常获取解析结果，虽然不能再导向另一个地址，但是至少无法获取 IP 是可以做到的。

解决方案是再对公钥进行一次加密，只不过不使用加密查询结果的私钥，而是每个区域特殊生成的密钥对。为了描述方便，下文简单称加密查询结果的公钥、私钥为「公钥」、「私钥」，称加密「公钥」的公钥、私钥为「区域公钥」、「区域私钥」。该公钥使用父区域的区域私钥签名，比如 chralpha.com 的公钥由 com 区域进行签名。父区域也负责核实子区域公钥真实性。这样按顺序一层一层形成 信任链，信任链顶端则是根区，根区自然无法再通过父区域私钥签名，而是通过有关责任机构背书。

由此，DNS 查询结果便不容易篡改了。但这只是保证了数据真实性，毕竟中间人只是不能伪造，但还是能查看查询内容，也依然能够根据规则拦截。所以，你不容易被骗，但是可以被捂住耳朵，压根得不到回应，自然也就无法连接。

DoT/DoH
DNSSEC 保证数据不被篡改已经迈出了很大一步，但是仍然能够被识别、被阻断。为此，IETF 小组提出两个加密 DNS 协议：DNS over TLS (DoT) 和 DNS over HTTPS (DoH)。

DNS over TLS (DoT) 通过传输层安全协议（TLS）加密打包整个 DNS 协议，从而防止中间人窃听、篡改。RFC 7858 及 RFC 8310 定义了 DNS over TLS。

DNS over HTTPS (DoH) 也是一种安全化域名解析方案，但目前尚属于实验性阶段。DoH 通过 HTTPS 加密传输进行 DNS 请求，从而保证传输数据可靠性和隐私性。当前，该方案由 IETF 支持，其规范文档以 RFC 8484 的名义发布。

由于 HTTPS 需要经过多次数据传输才能完成验证，所以 DoH 域名解析耗时会显著增加。而在实验性阶段，目前直接对 DoH 支持的终端设备较少，通常需要在本地系统或者本地网络服务器上安装 DoH 代理。当然，使用的 DNS 服务器也必须支持 DoH 才行，下图为部分公共 DNS 支持情况。



乍一看 DoT 与 DoH 好像挺相似，毕竟 HTTPS 就是应用了 SSL/TLS 加密协议的 HTTP 传输协议，但是这两者区别明显。DoT 使用基本 TCP 连接而 DoH 使用 HTTP 与 HTTP/2 连接；DoT 使用自己 853 端口连接而 DoH 使用标准 443 端口连接。这样 DoH 可以伪装成一般的 HTTP 流量，加密后他人也无从知晓里面究竟是什么。而 DoT 使用唯一 853 端口，至少中间人可以知道这是 DNS 请求，尽管他们也无法获得请求内容，所以也不敢随便封禁。

关于「DoT or DoH」的问题一直争论不休。DNS 架构师 Paul Vixie 曾在社交媒体上表态：

“RFC 8484 会给互联网安全带来隐患。抱歉向您泼了冷水。就像一群鸭子一样，囚犯们找到了庇护所。”

“DoH 是企业和其他私有网络的过顶旁路。但是DNS是控制平面的一部分，网络运营商必须能够监视和过滤它。使用 DoT，永远不要使用 DoH。”

然而这场辩论双方都有正当理由，只是取舍不同。DoT 更有利于网络安全，而 DoH 则比较倾向「人权保护」。事实上共识还是存在的，没有人认为 DNS 请求不应被加密，只不过对如何做得更好有不同意见。

代理下的 DNS 行为
即便解决了 DNS 污染等，依旧无法保证能够畅通连接互联网，使用代理才是正解。不过本文不会剖析代理行为，只聚焦 代理下的 DNS 行为。

![图片](https://user-images.githubusercontent.com/79394963/150638751-7388af78-1536-4b4f-b983-069142bfcdc3.png)






DNS 解析流程，不过都是默认 直连 下的请求。而在代理环境下还是有许多差别，还是拿 chralpha.com 举例：

假设已经通过 某种协议 与代理服务端建立通信，由于这种协议与 SOCKS5 一样支持将域名封装在传输中
由于本地已经建立好代理，浏览器可以直接将域名 chralpha.com 封装在 SOCKS5 流量内发送至代理客户端
代理客户端通过 SS 将从浏览器收到的流量整理后发给代理服务端
代理服务端同样使用 SS 解析流量内信息，从中获取域名 chralpha.com
代理服务端对 DNS 服务器发起 chralpha.com 的查询请求，通常这是在代理服务端上完成的，也就是代理服务端负责 DNS 解析
代理服务端 DNS 解析与普通 DNS 解析并无差异。以上便是在代理环境下的一次 DNS 流程，后续得到 DNS 查询结果，代理服务端再对得到的 IP 发起请求，并将请求结果用 某种协议 发送回本地，完成一次访问。

当然，如果在本地部署关于 IP 的分流策略，那么代理客户端便会收到浏览器发来的流量后抽取域名，并在本地先执行一次 DNS 解析。如果判断无需代理，那么通常会直接复用这个查询到的 IP 发起请求；否则，仍然是将域名封装送往代理服务端，而代理服务端会对这个域名再次发起 DNS 查询，这次查询不受之前代理客户端查询影响，往往也能得到正确的结果。

所以，「代理环境下无视 DNS 污染」是有一定道理的。这也是为什么在解锁失效时推荐使用白名单或全局代理——将更多行为转交代理服务端完成。

后续 DNS 一定会越来越安全，我们也定能享受技术带来的安逸。

